/*
  Copyright (c) 2019, miya
  Modified by airpocket, 2025
  All rights reserved.
  (BSD 2-Clause License)
*/

#include <MediaPlayer.h>
#include <OutputMixer.h>
#include <MemoryUtil.h>
#include <math.h>

const int MIXER_VOLUME = -160;
const int32_t S_BUFFER_SIZE = 8192;
uint8_t s_buffer[S_BUFFER_SIZE];
bool err_flag = false;

// ======= 波形パラメータ =======
const float SAMPLE_RATE = 48000.0f;
float freq = 440.0f;          // 初期周波数(Hz)
int volume = 50;              // 抽象化したボリューム値(0〜100)
int amplitude = 0;            // 実際のPCM振幅(0〜32767)
float phase = 0.0f;
const float PI2 = 6.2831853f;

// ======= Audio関連 =======
MediaPlayer *player;
OutputMixer *mixer;

// ======= 入力ピン設定 =======
const int POT_FREQ = A0;         // 周波数制御用
const int POT_VOL  = A1;         // ボリューム制御用
const float FREQ_MIN = 1.0f;
const float FREQ_MAX = 1000.0f;
const int ADC_FREQ_MIN = 10;     // 周波数入力範囲下限
const int ADC_FREQ_MAX = 620;    // 周波数入力範囲上限
const int ADC_VOL_MIN  = 10;     // ボリューム入力範囲下限
const int ADC_VOL_MAX  = 620;    // ボリューム入力範囲上限

// ======= コールバック =======
static void error_callback(const ErrorAttentionParam *errparam)
{
  if (errparam->error_code > AS_ATTENTION_CODE_WARNING) {
    err_flag = true;
  }
}

static void mixer_done_callback(MsgQueId id, MsgType type, AsOutputMixDoneParam *param)
{
  return;
}

static void mixer_send_callback(int32_t id, bool is_end)
{
  AsRequestNextParam next;
  next.type = (!is_end) ? AsNextNormalRequest : AsNextStopResRequest;
  AS_RequestNextPlayerProcess(AS_PLAYER_ID_0, &next);
  return;
}

static bool player_done_callback(AsPlayerEvent event, uint32_t result, uint32_t sub_result)
{
  return true;
}

// ======= 波形生成関数 =======
void generate_sine(int16_t *buf, uint32_t frames)
{
  amplitude = (int)(32767.0f * (volume / 100.0f)); // 0〜100を0〜32767に変換
  float phase_inc = PI2 * freq / SAMPLE_RATE;

  for (uint32_t i = 0; i < frames; i++) {
    int16_t v = (int16_t)(sin(phase) * amplitude);
    buf[i * 2 + 0] = v; // Left
    buf[i * 2 + 1] = v; // Right
    phase += phase_inc;
    if (phase >= PI2) phase -= PI2;
  }
}

// ======= PCMデコードコールバック =======
void player_decode_callback(AsPcmDataParam pcm_param)
{
  int16_t *buf = (int16_t*)pcm_param.mh.getPa();
  uint32_t frames = pcm_param.size / 4;

  generate_sine(buf, frames);
  mixer->sendData(OutputMixer0, mixer_send_callback, pcm_param);
}

// ======= 初期化 =======
void setup()
{
  Serial.begin(115200);
  Serial.println("=== Spresense: Sine Generator (Freq=A0, Volume=A1, 0〜100抽象化) ===");
  Serial.println("A0: 周波数 30〜610 → 1〜1000Hz");
  Serial.println("A1: ボリューム 30〜610 → 0〜100");
  Serial.println("音量は内部的に 0〜32767 の16bit PCM振幅に変換されます。");

  initMemoryPools();
  createStaticPools(MEM_LAYOUT_PLAYER);

  player = MediaPlayer::getInstance();
  mixer = OutputMixer::getInstance();

  player->begin();
  mixer->activateBaseband();

  player->create(MediaPlayer::Player0, error_callback);
  mixer->create(error_callback);
  player->activate(MediaPlayer::Player0, player_done_callback);
  mixer->activate(OutputMixer0, mixer_done_callback);

  usleep(100 * 1000);
  player->init(MediaPlayer::Player0, AS_CODECTYPE_WAV, "/mnt/sd0/BIN",
               AS_SAMPLINGRATE_48000, AS_BITLENGTH_16, AS_CHANNEL_STEREO);
  mixer->setVolume(MIXER_VOLUME, 0, 0);

  memset(s_buffer, 0, sizeof(s_buffer));
  player->writeFrames(MediaPlayer::Player0, s_buffer, S_BUFFER_SIZE);
  player->start(MediaPlayer::Player0, player_decode_callback);

  Serial.println("[OK] Audio initialized.");
  Serial.println("----------------------------------------------");
}

// ======= メインループ =======
void loop()
{
  player->writeFrames(MediaPlayer::Player0, s_buffer, S_BUFFER_SIZE);

  // === 周波数制御 ===
  int rawFreq = analogRead(POT_FREQ);
  float newFreq;
  if (rawFreq <= ADC_FREQ_MIN) newFreq = FREQ_MIN;
  else if (rawFreq >= ADC_FREQ_MAX) newFreq = FREQ_MAX;
  else newFreq = FREQ_MIN + (FREQ_MAX - FREQ_MIN) *
                ((float)(rawFreq - ADC_FREQ_MIN) / (ADC_FREQ_MAX - ADC_FREQ_MIN));
  freq = newFreq;

  // === ボリューム制御 ===
  int rawVol = analogRead(POT_VOL);
  int newVol;
  if (rawVol <= ADC_VOL_MIN) newVol = 0;
  else if (rawVol >= ADC_VOL_MAX) newVol = 100;
  else newVol = (int)(100.0f * (float)(rawVol - ADC_VOL_MIN) / (ADC_VOL_MAX - ADC_VOL_MIN));
  volume = newVol;

  // === デバッグ出力 ===
  static unsigned long lastPrint = 0;
  if (millis() - lastPrint > 100) {
    lastPrint = millis();
    Serial.print("[A0]="); Serial.print(rawFreq);
    Serial.print("  [A1]="); Serial.print(rawVol);
    Serial.print("  ->  [freq]="); Serial.print(freq, 1);
    Serial.print(" Hz  [vol]="); Serial.print(volume);
    Serial.print("%  [amplitude]="); Serial.println(amplitude);
  }

  if (err_flag) {
    Serial.println("[ERROR] Audio system halted!");
    player->stop(MediaPlayer::Player0);
    while (1);
  }

  usleep(1000);
}
